#include "..\headers\define.h"
#include "..\headers\command.h"
#include "..\headers\sfall\define_extra.h"
#include "..\headers\fo2tweaks\fo2tweaks.h"

#define BODYPART_HEAD 0
#define BODYPART_LEFT_ARM 1
#define BODYPART_RIGHT_ARM 2
#define BODYPART_TORSO_UNCALLED 3
#define BODYPART_RIGHT_LEG 4
#define BODYPART_LEFT_LEG 5
#define BODYPART_EYES 6
#define BODYPART_GROIN 7
//#define BODYPART_TORSO_CALLED 8 ???

//critical hit tables
#define CRITICAL_VALUE_TYPE_MULT 0
#define CRITICAL_VALUE_TYPE_EFFECTS 1

#define NAME "gl_g_damage_mod"
#define set_damage_mod "damage_mod"
#define sec_damage_mod "damage_mod"
#define set_damage_mod_new_burst "new_burst"

#define is_critical_hit(flags)  ((flags bwand DAM_CRITICAL) != 0)
#define is_bypassing_armor(flags) ((flags bwand DAM_BYPASS) != 0)

variable begin
  old_total := 0, new_total := 0;
end

procedure start;
procedure damage_handler;
procedure get_dr_dt(variable attacker, variable target, variable target_flags, variable dmg_type, variable dr_mod);

procedure start begin
  if game_loaded then begin
    variable enabled := fo2tweaks_setting(sec_main, set_damage_mod);
    if enabled == 1 then begin
      register_hook_proc(HOOK_COMBATDAMAGE, damage_handler);
      ndebug("initialized");
    end
  end
end

// 1.2 damage has 20% chance to be rounded up to 2
procedure round_chance(variable dmg) begin
  variable base_dmg := floor2(dmg);
  variable chance := (dmg - base_dmg)*100;
  variable rnd := random(1, 100);
  variable final_dmg;

  if dmg < 0 then begin
    ndebug("dmg is " + dmg + ", rounded dmg is 0");
    return 0;
  end

  ndebug("dmg is " + dmg + ", chance to round up is " + chance + "%, rnd is " + rnd);
  if chance > rnd then begin
    final_dmg := base_dmg + 1;
  end else begin
    final_dmg := base_dmg;
  end
  ndebug("rounded dmg is " + final_dmg);
  return final_dmg;
end

procedure get_critical_level(variable who) begin
  variable level := random(0, 5);
  if has_trait(TRAIT_PERK, who, PERK_better_criticals) then level := level + 1;
  return level;
end

// returns [critical mult, critical effect flags]
procedure get_critical_type(variable attacker, variable target) begin
  variable mult := 2; //default
  variable flags := 0; //default
  variable chance := get_critter_stat(attacker, STAT_crit_chance);
  variable rnd := random(0,100);
  variable crit_level;

  if rnd > chance then return [mult/2.0, flags]; //not critical

  crit_level := get_critical_level(attacker);
  mult := get_critical_table(critter_kill_type(target), BODYPART_TORSO_UNCALLED, crit_level, CRITICAL_VALUE_TYPE_MULT);
  flags := get_critical_table(critter_kill_type(target), BODYPART_TORSO_UNCALLED, crit_level, CRITICAL_VALUE_TYPE_EFFECTS);
  ndebug("critical level " + crit_level + ", critical mult " + mult + ", flags " + flags);
  return [mult/2.0, flags];
end

procedure get_bullet_damage(variable dmg_min, variable dmg_max, variable ranged_bonus, variable dt,
  variable ammo_mult, variable critical_mult, variable difficulty_mult, variable dr_mult)
begin
  variable rd := random(dmg_min, dmg_max);

  /* original formula
    ND = net damage value
    RD = random damage value produced from weapons hit damage range
    RB = ranged bonus (RB=0 unless the player has Bonus Ranged Damage perk)
    CM = critical hit damage multiplier (if no critical hit then CM=2, otherwise assigned value from critical hit table)
    ADR = armor damage resistance value
    ADT = armor damage threshold value
    X = ammo dividend
    Y = ammo divisor
    RM = ammo resistance modifier (only value allowed to be negative or positive in the equation)
    CD = combat difficulty multiplier (Easy=75, Normal=100, Hard=125)

    ND = ( ((RD+RB)*(X*CM)/Y/2 * CD/100) - ADT) * ((100-(ADR+RM))/100 )
    nd := ( ((rd + rb) * (x * cm) / y / 2.0 * (cd / 100.0) ) - adt) * ( (100.0 - (adr + rm)) / 100.0 ); // original
    nd := ( ((rd + rb) * (1.0*x/y) * (cm/2.0) * (cd/100.0) ) - adt) * ( (100.0 - (adr + rm)) / 100.0 ); // original, ease of reading
  */

  /* new formula: dt is subtracted first, then the rest is multiplied by corresponding miltipliers */

  variable dmg := round_chance(1.0 * (rd + ranged_bonus - dt) * ammo_mult * critical_mult * difficulty_mult * dr_mult);
  ndebug("rd " + rd + " ranged_bonus " + ranged_bonus + " dt " + dt + " ammo_mult " + ammo_mult
        + " critical_mult " + critical_mult + " difficulty_mult " + difficulty_mult + " dr_mult " + dr_mult
        + ", dmg " + dmg);
  if dmg < 0 then dmg := 0;
  return dmg;
end

procedure get_total_damage(
  variable attacker, variable target, variable dmg_type, variable dr_mod,
  variable dmg_min, variable dmg_max,
  variable ranged_bonus, variable ammo_mult, variable critical_mult, variable difficulty_mult,
  variable bullets_number)
begin
  variable total_damage := 0, bullet_damage := 0, i, critical_type, flags, dr_dt,
  dr_mult, dt;

  //first bullet to hit keeps all the original mults
  dr_dt := get_dr_dt(attacker, target, dmg_type, dr_mod, flags);
  dr_mult := dr_dt[0];
  dt := dr_dt[1];

  total_damage := get_bullet_damage(dmg_min, dmg_max, ranged_bonus, dt, ammo_mult, critical_mult, difficulty_mult, dr_mult);

  //burst: consecutive bullets roll their own critical damage, including armor bypass, but excluding crippling effects
  if bullets_number > 1 then begin
    for (i := 2; i <= bullets_number; i++) begin
      critical_type := get_critical_type(attacker, target);
      critical_mult := critical_type[0];
      flags := critical_type[1];
      dr_dt := get_dr_dt(attacker, target, dmg_type, dr_mod, flags);
      dr_mult := dr_dt[0];
      dt := dr_dt[1];

      bullet_damage := get_bullet_damage(dmg_min, dmg_max, ranged_bonus, dt, ammo_mult, critical_mult, difficulty_mult, dr_mult);
      total_damage += bullet_damage;
    end
  end

  //pyromaniac
  if has_trait(TRAIT_PERK, attacker, PERK_pyromaniac_perk) and dmg_type == DMG_fire then begin
    ndebug("pyromaniac: +5 dmg");
    total_damage := total_damage + 5;
  end
  //living anatomy
  if has_trait(TRAIT_PERK, attacker, PERK_living_anatomy_perk)
    and critter_kill_type(target) != KILL_TYPE_robot_kills
  then begin
    ndebug("living anatomy: +5 dmg");
    total_damage := total_damage + 5;
  end

  return total_damage;
end

procedure get_resist_defines(variable dmg_type) begin
  variable ar_dt_type, ar_dr_type, cr_dt_type, cr_dr_type, dmgtype_determined := 0;

  if dmg_type == DMG_normal_dam then begin
    cr_dr_type := STAT_dmg_resist;
    cr_dt_type := STAT_dmg_thresh;
    dmgtype_determined := 1;
  end else if dmgtype_determined == 0 and dmg_type == DMG_laser then begin
    cr_dr_type := STAT_dmg_resist_laser;
    cr_dt_type := STAT_dmg_thresh_laser;
    dmgtype_determined := 1;
  end else if dmgtype_determined == 0 and dmg_type == DMG_fire then begin
    cr_dr_type := STAT_dmg_resist_fire;
    cr_dt_type := STAT_dmg_thresh_fire;
    dmgtype_determined := 1;
  end else if dmgtype_determined == 0 and dmg_type == DMG_plasma then begin
    cr_dr_type := STAT_dmg_resist_plasma;
    cr_dt_type := STAT_dmg_thresh;
    dmgtype_determined := 1;
  end else if dmgtype_determined == 0 and dmg_type == DMG_electrical then begin
    cr_dr_type := STAT_dmg_resist_electrical;
    cr_dt_type := STAT_dmg_thresh_electrical;
    dmgtype_determined := 1;
  end else if dmgtype_determined == 0 and dmg_type == DMG_emp then begin
    cr_dr_type := STAT_dmg_resist_emp;
    cr_dt_type := STAT_dmg_thresh_emp;
    dmgtype_determined := 1;
  end else if dmgtype_determined == 0 and dmg_type == DMG_explosion then begin
    cr_dr_type := STAT_dmg_resist_explosion;
    cr_dt_type := STAT_dmg_thresh_explosion;
    dmgtype_determined := 1;
  end
  return [cr_dr_type, cr_dt_type];
end

//returns [dr_mult, dt]
procedure get_dr_dt(variable attacker, variable target, variable dmg_type, variable dr_mod, variable target_flags)
begin
  variable target_dr, target_dt, final_dr, final_dt, dr_mult, resist_defines, dr_type, dt_type;

  //determine resits types
  resist_defines := get_resist_defines(dmg_type);
  dr_type := resist_defines[0];
  dt_type := resist_defines[1];
  ndebug("critter dr type is " + dr_type + ", dt type is " + dt_type);

  //get critter resists - includes armor
  target_dr := get_critter_stat(target, dr_type);
  target_dt := get_critter_stat(target, dt_type);
  if has_trait(TRAIT_TRAIT, attacker, TRAIT_finesse) then begin
    ndebug("attacking with finesse, extra 30% to dr");
    target_dr := target_dr + 30;
  end
  ndebug("target dr is " + target_dr + ", target_dt is " + target_dt);

  if target_dr > 90 then target_dr := 90; //cap DR
  if is_bypassing_armor(target_flags) then begin //critical bypass armor
    ndebug("armor bypassing critical, reducing dt and dr by magnitude of 5");
    target_dr := target_dr * 0.2;
    target_dt := target_dt * 0.2;
  end else if has_trait(TRAIT_PERK, attacker, PERK_weapon_penetrate) > 0 then begin //weapon penetrate perk
    ndebug("weapon has penetrate perk, reducing dt by magnitude of 5");
    target_dt := target_dt * 0.2;
  end

  ndebug("target dr is " + target_dr + ", dr_mod is " + dr_mod);
  final_dr := 1.0 * target_dr * (100.0 + dr_mod) / 100.0;
  ndebug("final dr is " + final_dr);
  if final_dr < 0 then final_dr := 0;
  if final_dr > 90 then final_dr := 90.0;
  dr_mult := (100.0 - final_dr) / 100.0;

  final_dt := 1.0 * target_dt * (100.0 + dr_mod) / 100.0;
  if final_dt < 0 then final_dt := 0;
  ndebug("dr_mult is " + dr_mult);
  ndebug("final dt is " + final_dt);

  return [dr_mult, final_dt];
end

procedure damage_handler begin
  /*
    Runs when:
    1) Game calculates how much damage each target will get. This includes primary target as well as all extras (explosions and bursts). This happens BEFORE the actual attack animation.
    2) AI decides whether it is safe to use area attack (burst, grenades), if he might hit friendlies.
    Does not run for misses, or non-combat damage like dynamite explosions.

    critter arg1  - The target
    critter arg2  - The attacker
    int     arg3  - The amount of damage to the target
    int     arg4  - The amount of damage to the attacker
    int     arg5  - The special effect flags for the target
    int     arg6  - The special effect flags for the attacker
    int     arg7  - The weapon used in the attack
    int     arg8  - The bodypart that was struck
    int     arg9  - Damage Multiplier (this is divided by 2, so a value of 3 does 1.5x damage, and 8 does 4x damage. Usually it's 2, but with Silent Death perk and the corresponding attack conditions, it's 4; for critical hits, the value is taken from the critical table)
    int     arg10 - Number of bullets actually hit the target (1 for melee attacks)
    int     arg11 - The amount of knockback to the target
    int     arg12 - Attack Type (see ATKTYPE_* constants)

    int     ret1 - The damage to the target
    int     ret2 - The damage to the attacker
    int     ret3 - The special effect flags for the target
    int     ret4 - The special effect flags for the attacker
    int     ret5 - The amount of knockback to the target
  */

  variable target := get_sfall_arg;
  variable attacker := get_sfall_arg;
  variable target_damage := get_sfall_arg;
  variable attacker_damage := get_sfall_arg;
  variable target_flags := get_sfall_arg;
  variable attacker_flags := get_sfall_arg;
  variable weapon := get_sfall_arg;
  variable bodypart := get_sfall_arg;
  variable damage_multiplier := get_sfall_arg;
  variable bullets_number := get_sfall_arg;
  variable knockback_distance := get_sfall_arg;
  variable attack_type := get_sfall_arg;

  variable nd := 0, rd, ranged_bonus := 0, cm, adr := 0, adt := 0, x := 1, y := 1, dr_mod := 0, cd;
  variable begin
    armor;
    dmg_type;
    cd_setting;
    i;
    ammo_mult;
    difficulty_mult;
    critical_mult;
    dr_mult;


    ar_dt_type;
    ar_dr_type;
    cr_dt_type;
    cr_dr_type;

    natural_dr;
    target_dr;
    target_dt;
    final_dr;
    final_dt;
    weapon_pid;
    dmg_min;
    dmg_max;
    ammo_pid;
    natural_dt;
    resist_defines;
    fine;

    table;
    t;
    levels;
    level;
  end


  if weapon then begin
    ndebug("weapon name is " + obj_name(weapon));
    weapon_pid := obj_pid(weapon);
    dmg_min := get_proto_data(weapon_pid, PROTO_WP_DMG_MIN);
    dmg_max := get_proto_data(weapon_pid, PROTO_WP_DMG_MAX);
    ndebug("dmg_minmax - " + dmg_min + ":" + dmg_max);
    ammo_pid := get_active_ammo_pid(attacker);
  end else begin //hth or melee
    ndebug("unarmed attack, skipping");
    return;
  end
  if not ammo_pid then begin
    ndebug("weapon has no ammo, skipping");
    return;
  end

  if not is_critter(target) then begin //hit a wall?
    ndebug("target " + obj_name(target) + " is not a critter, skipping");
    return;
  end

  //ranged_bonus - bonus ranged damage perk
  ranged_bonus := 2 * has_trait(TRAIT_PERK, attacker, PERK_bonus_ranged_damage);

  //cm - critical hit multiplier, default 2
  cm := damage_multiplier;

  //ammo: damage resistance mod
  dr_mod := get_proto_data(ammo_pid, PROTO_AM_DR_MOD);
  ndebug("ammo dr mod is " + dr_mod);

  dmg_type := weapon_dmg_type(weapon);
  ndebug("damage type is " + dmg_type);

  //cd - combat difficulty  multiplier
  cd_setting := combat_difficulty;
  cd := 75 + cd_setting * 25;

  ammo_mult := (100 + dr_mod) / 100.0;

  difficulty_mult := cd / 100.0;
  critical_mult := damage_multiplier / 2.0;

/*
  get_total_damage( attacker, target, dmg_type, dr_mod, dmg_min, dmg_max,
     ranged_bonus, ammo_mult, critical_mult, difficulty_mult, bullets_number)
*/
  nd := get_total_damage(attacker, target, dmg_type, dr_mod, dmg_min, dmg_max,
    ranged_bonus, ammo_mult, critical_mult, difficulty_mult, bullets_number);

  ndebug("rd " + rd + ", ranged_bonus " +  ranged_bonus + ", x " +  x + ", cm " +  cm + ", y " +  y + ", cd " +  cd
      + ", adt " +  adt + ", adr " +  adr + ", dr_mod " +  dr_mod + ", final dr " + final_dr + ", final dt " + final_dt
      + ", ammo_mult " + ammo_mult);

  //logging for comparison
  old_total += target_damage;
  new_total += nd;

  ndebug("attacker " + obj_name(attacker) + ", target " + obj_name(target) + ", old damage " + target_damage +
        ", new damage " + nd + ", old total " + old_total + ", new total " + new_total);

  set_sfall_return(nd);
  set_sfall_arg(2, nd);
end
